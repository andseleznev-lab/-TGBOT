# План реализации: Интеграция платежной системы Юкасса

**Тикет**: T-003
**PRD**: `docs/prd/T-003.prd.md`
**Автор**: Claude
**Дата создания**: 2026-02-07
**Статус**: PLAN_APPROVED

---

## Краткое описание

Добавляем платежную систему Юкасса с временной блокировкой слотов (TTL 24 часа). Пользователь бронирует слот → слот помечается как `locking` → получает ссылку на оплату → после успешной оплаты слот переходит в `book`, иначе через 24 часа возвращается в `free`.

---

## Архитектура решения

### Обзор

**Схема работы**:
```
1. Пользователь выбирает слот
   ↓
2. Frontend → Make.com: запрос на бронирование
   ↓
3. Make.com:
   - Принимает выбранный слот (все слоты в slots.json изначально free)
   - Удаляет слот из slots.json на GitHub (убираем из показа другим пользователям)
   - Сохраняет слот в Data Store/Google Sheets со статусом "locking", user_id, locked_until
   - Создаёт платёж в Юкассе
   - Возвращает payment_url
   ↓
4. Frontend: открывает Telegram WebView с payment_url
   ↓
5. Пользователь оплачивает через Юкассу
   ↓
6. Юкасса → Make.com webhook: payment.succeeded
   ↓
7. Make.com:
   - Обновляет слот в Data Store/Google Sheets: status → "book", удаляет locked_until
   - Создаёт встречу в Zoom
   - Добавляет встречу в Google Calendar психолога
   - Отправляет уведомление пользователю с приглашением и ссылкой
   ↓
8. Пользователь видит подтверждение в "Мои записи"

TTL Мониторинг (отдельный процесс):
Make.com cron (каждый час):
  - Читает Data Store/Google Sheets (где хранятся locking слоты)
  - Находит слоты с status: "locking" и просроченным locked_until
  - Возвращает слот обратно в slots.json на GitHub (делает доступным снова)
  - Удаляет запись из Data Store/Google Sheets
```

### Диаграмма компонентов

```
┌──────────────┐
│    User      │
└──────┬───────┘
       │ выбирает слот
       ▼
┌────────────────────────────────────────┐
│  Frontend (app.js)                     │
│  - handleBookSlot()                    │
│  - openPaymentWindow()                 │
│  - checkPaymentStatus()                │
└──────┬─────────────────────────────────┘
       │ POST /book-slot
       ▼
┌────────────────────────────────────────┐
│  Make.com                              │
│  ┌──────────────────────────────────┐  │
│  │ Scenario: Book Slot              │  │
│  │ 1. Create payment in Yookassa    │  │
│  │ 2. Delete slot from slots.json   │  │
│  │ 3. Save to Data Store (locking)  │  │
│  │ 4. Return payment_url            │  │
│  └──────────────────────────────────┘  │
│                                        │
│  ┌──────────────────────────────────┐  │
│  │ Webhook: Payment Succeeded       │  │
│  │ 1. Verify webhook signature      │  │
│  │ 2. Update Data Store (book)      │  │
│  │ 3. Create Zoom & Google Calendar │  │
│  │ 4. Send notification to user     │  │
│  └──────────────────────────────────┘  │
│                                        │
│  ┌──────────────────────────────────┐  │
│  │ Cron: TTL Monitor (hourly)       │  │
│  │ 1. Read slots.json               │  │
│  │ 2. Find expired locking slots    │  │
│  │ 3. Update to free                │  │
│  │ 4. Commit to git                 │  │
│  └──────────────────────────────────┘  │
└──────┬─────────────────────────────────┘
       │ payment_url
       ▼
┌────────────────────────────────────────┐
│  Yookassa                              │
│  - Create payment                      │
│  - Process payment                     │
│  - Send webhook on success/fail        │
└────────────────────────────────────────┘
       │ webhook
       ▼
    Make.com
```

---

## Затрагиваемые файлы

### Изменяемые файлы

**Frontend**:

- `config.js`
  - Новые константы:
    - `YOOKASSA_PAYMENT_ENDPOINT` — URL Make.com для создания платежа
    - `PAYMENT_RETURN_URL` — URL возврата после оплаты
    - `SERVICE_PRICES` — цены услуг (для отображения)

- `app.js`
  - Изменения:
    - `handleBooking()` — теперь вызывает `createPayment()` вместо прямого бронирования
    - `renderAvailableSlots()` — добавить визуализацию статуса `locking`
    - `loadUserBookings()` — показывать слоты в статусе `locking` с таймером
  - Новые функции:
    - `createPayment(slotId, serviceId)` — создаёт платёж через Make.com
    - `openPaymentWindow(paymentUrl)` — открывает Telegram WebView
    - `checkPaymentStatus(slotId)` — проверяет статус оплаты (fallback)
    - `renderLockingSlot(slot)` — рендерит слот с таймером обратного отсчета
    - `calculateTimeRemaining(lockedUntil)` — вычисляет оставшееся время

- `style.css`
  - Новые классы:
    - `.slot--locking` — стили для слота в статусе locking
    - `.payment-timer` — таймер обратного отсчета
    - `.payment-btn` — кнопка "Оплатить"

**Data**:

- `slots.json` (GitHub)
  - Что изменим: содержит ТОЛЬКО свободные слоты
  - Структура слота: `{ id, date, time, service }` (БЕЗ status, user_id, locked_until)
  - Слоты с `locking` и `book` удаляются из этого файла

- **Data Store/Google Sheets** (новое хранилище)
  - Содержит: слоты со статусом `locking` и `book`
  - Поля:
    - `status` — "locking" | "book"
    - `user_id` — Telegram user ID (для locking/book)
    - `locked_until` — ISO 8601 timestamp (только для locking)

**Backend (Make.com)**:

- **Сценарий 1: "Create Payment"**
  - Вход: `{ slot_id, user_id, service }`
  - Логика:
    1. Создать платёж в Юкассе
    2. Удалить слот из slots.json на GitHub
    3. Сохранить в Data Store/Google Sheets:
       - status → "locking"
       - user_id → из запроса
       - locked_until → now() + 24h
    4. Коммит в git (обновлённый slots.json)
  - Выход: `{ success: true, payment_url: "..." }`

- **Сценарий 2: "Yookassa Webhook"**
  - Вход: webhook от Юкассы (`payment.succeeded`)
  - Логика:
    1. Проверить подпись webhook
    2. Извлечь slot_id, user_id из metadata
    3. Обновить Data Store/Google Sheets:
       - status → "book"
       - удалить locked_until
    4. Создать Zoom meeting
    5. Добавить встречу в Google Calendar психолога
    6. Отправить уведомление пользователю с приглашением и ссылкой

- **Сценарий 3: "TTL Monitor (Cron)"**
  - Запуск: каждый час
  - Логика:
    1. Прочитать Data Store/Google Sheets
    2. Найти слоты: status === "locking" && locked_until < now()
    3. Для каждого просроченного слота:
       - Вернуть слот обратно в slots.json на GitHub (добавить как free)
       - Удалить запись из Data Store/Google Sheets
    4. Коммит в git (обновлённый slots.json, если были изменения)

### Новые файлы

Не требуется.

---

## Компоненты и функции

### Frontend компоненты

#### Функция 1: `createPayment(slotId, serviceId)`

**Назначение**: Создаёт платёж через Make.com и получает payment_url

**Параметры**:
- `slotId` (string): ID слота (например, "pslot_01")
- `serviceId` (string): ID услуги (package, family, single, diagnosis)

**Возвращает**: `Promise<{ success: boolean, payment_url?: string, error?: string }>`

**Логика**:
1. Получить user_id из Telegram WebApp API
2. Найти цену услуги в CONFIG.SERVICE_PRICES
3. Валидация:
   - slotId не пустой
   - serviceId валидный
   - user_id получен
4. Показать loader ("Создание платежа...")
5. POST запрос к Make.com:
   ```javascript
   const payload = {
     action: 'create_payment',
     slot_id: slotId,
     user_id: userId,
     service: serviceId
   };
   ```
6. Обработать ответ:
   - success: true → вернуть payment_url
   - success: false → показать ошибку
7. Скрыть loader

**Пример использования**:
```javascript
const result = await createPayment('pslot_01', 'package');
if (result.success) {
  openPaymentWindow(result.payment_url);
} else {
  showErrorPopup(result.error || 'Не удалось создать платёж');
}
```

**Обработка ошибок**:
- `NetworkError` — "Проверьте интернет-соединение"
- `slot_locked` — "Этот слот уже забронирован другим пользователем"
- `slot_not_found` — "Слот не найден. Обновите расписание."
- `yookassa_error` — "Сервис оплаты недоступен. Попробуйте позже."

---

#### Функция 2: `openPaymentWindow(paymentUrl)`

**Назначение**: Открывает платёжную ссылку в Telegram WebView

**Параметры**:
- `paymentUrl` (string): URL страницы оплаты Юкассы

**Возвращает**: void

**Логика**:
1. Проверить наличие Telegram WebApp API
2. Вызвать `window.Telegram.WebApp.openLink(paymentUrl, { try_instant_view: true })`
3. HapticFeedback: `impactOccurred('medium')`
4. Установить флаг `State.isPaymentInProgress = true`

**Пример использования**:
```javascript
openPaymentWindow('https://yookassa.ru/checkout/payments/abc123');
```

---

#### Функция 3: `renderLockingSlot(slot)`

**Назначение**: Рендерит слот в статусе `locking` с таймером обратного отсчета в экране "Мои записи"

**Параметры**:
- `slot` (Object): объект слота из API Make.com (пользователь видит только СВОИ locking слоты)

**Возвращает**: HTMLElement (DOM элемент)

**Логика**:
1. Создать div с классом `.slot.slot--locking`
2. Вычислить оставшееся время: `calculateTimeRemaining(slot.locked_until)`
3. Отобразить таймер:
   ```html
   <div class="payment-timer">
     Оплатите до: <span class="timer-value">23 ч 15 мин</span>
   </div>
   ```
4. Добавить кнопку "Оплатить" (если это слот текущего пользователя)
5. Стили:
   - background: `rgba(255, 100, 100, 0.3)` (бледно-красный)
   - opacity: 0.7
   - pointer-events: none (если не свой слот)
6. Запустить interval для обновления таймера (каждую минуту)

**Пример использования**:
```javascript
const slotElement = renderLockingSlot({
  id: 'pslot_01',
  status: 'locking',
  user_id: '123456789',
  locked_until: '2026-02-08T10:00:00Z'
});
container.appendChild(slotElement);
```

---

#### Функция 4: `calculateTimeRemaining(lockedUntil)`

**Назначение**: Вычисляет оставшееся время до истечения блокировки

**Параметры**:
- `lockedUntil` (string): ISO 8601 timestamp

**Возвращает**: `{ hours: number, minutes: number, isExpired: boolean }`

**Логика**:
```javascript
const now = new Date();
const end = new Date(lockedUntil);
const diff = end - now;

if (diff <= 0) return { hours: 0, minutes: 0, isExpired: true };

const hours = Math.floor(diff / (1000 * 60 * 60));
const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));

return { hours, minutes, isExpired: false };
```

---

### Backend компоненты (Make.com)

**Сценарий 1: Create Payment**
- Модули:
  1. HTTP Request (прием запроса от фронтенда)
  2. Yookassa API: Create Payment (создание платежа)
  3. GitHub API: Read slots.json
  4. JSON Transformer: Remove slot from slots.json
  5. Data Store/Google Sheets: Save locking slot with TTL
  6. GitHub API: Commit updated slots.json
  7. HTTP Response (возврат payment_url)

**Сценарий 2: Yookassa Webhook**
- Модули:
  1. Webhook Receiver (прием webhook от Юкассы)
  2. Verify Signature (проверка подписи)
  3. Data Store/Google Sheets: Update slot to "book" (удалить locked_until)
  4. Zoom API: Create Meeting
  5. Google Calendar API: Add event to психолог's calendar
  6. Telegram Bot API: Send Notification with meeting link

**Сценарий 3: TTL Monitor**
- Модули:
  1. Cron Trigger (каждый час)
  2. Data Store/Google Sheets: Read locking slots
  3. Iterator: Loop through locking slots
  4. Filter: locked_until < now (найти просроченные)
  5. GitHub API: Read slots.json
  6. JSON Transformer: Add expired slots back to slots.json (as free)
  7. Data Store/Google Sheets: Delete expired slots
  8. GitHub API: Commit updated slots.json (если были изменения)

---

## Потоки данных

### Основной поток (Happy Path)

1. Пользователь выбирает слот и нажимает "Забронировать"
   ↓
2. Frontend: `handleBooking(slotId, serviceId)`
   - Валидация входных данных (slotId, serviceId)
   - Вызов `createPayment(slotId, serviceId)`
   ↓
3. API запрос к Make.com
   ```json
   POST /webhook/create-payment
   {
     "action": "create_payment",
     "slot_id": "pslot_01",
     "user_id": "123456789",
     "service": "package"
   }
   ```
   ↓
4. Make.com: обработка
   - Создание платежа в Юкассе (amount: 75000, metadata: { slot_id, user_id })
   - Удаление слота из slots.json (скрываем от других пользователей)
   - Сохранение в Data Store/Google Sheets: status → "locking", locked_until → +24h
   - Коммит в git (обновление slots.json)
   ↓
5. Ответ Make.com
   ```json
   {
     "success": true,
     "payment_url": "https://yookassa.ru/checkout/payments/abc123"
   }
   ```
   ↓
6. Frontend: обработка ответа
   - `openPaymentWindow(payment_url)` → Telegram WebView
   - HapticFeedback: `impactOccurred('medium')`
   - Показ уведомления: "Перенаправляем на оплату..."
   ↓
7. Пользователь оплачивает через Юкассу
   ↓
8. Юкасса → Make.com webhook
   ```json
   {
     "event": "payment.succeeded",
     "object": {
       "id": "abc123",
       "status": "succeeded",
       "metadata": { "slot_id": "pslot_01", "user_id": "123456789" }
     }
   }
   ```
   ↓
9. Make.com: обработка webhook
   - Проверка подписи
   - Обновление Data Store/Google Sheets: status → "book", удалить locked_until
   - Создание Zoom meeting
   - Добавление встречи в Google Calendar психолога
   - Отправка уведомления пользователю с приглашением и ссылкой
   ↓
10. Результат для пользователя
    - Уведомление: "Оплата прошла! Вы забронировали консультацию на [дата] в [время]"
    - Отображение в "Мои записи" с Zoom-ссылкой

---

## Изменения UI

### Новые элементы интерфейса

**Компонент: Слот в статусе locking**
```html
<div class="slot slot--locking">
  <div class="slot__header">
    <span class="slot__time">10:00</span>
    <span class="slot__status">Оформляется</span>
  </div>
  <div class="payment-timer">
    Оплатите до: <span class="timer-value">23 ч 15 мин</span>
  </div>
  <button class="payment-btn">Оплатить 75 000 ₽</button>
</div>
```

**CSS классы**:
```css
.slot--locking {
  background: rgba(255, 100, 100, 0.3);
  opacity: 0.7;
  border: 1px solid rgba(255, 100, 100, 0.5);
  pointer-events: none; /* если не свой слот */
}

.slot--locking.slot--own {
  pointer-events: auto; /* если свой слот */
  cursor: pointer;
}

.payment-timer {
  font-size: 12px;
  color: var(--text-primary);
  margin-top: 8px;
}

.timer-value {
  font-weight: bold;
  color: #d32f2f; /* красный */
}

.payment-btn {
  background: var(--accent-primary);
  color: white;
  padding: 10px 20px;
  border-radius: 12px;
  margin-top: 12px;
  font-size: 14px;
  font-weight: 600;
  transition: var(--transition-normal);
}

.payment-btn:hover {
  background: #c89563; /* темнее */
  transform: scale(1.02);
}
```

### Изменения в существующих экранах

**Экран "Выбор времени" (Booking)**:
- Слоты с `status: "locking"` НЕ отображаются другим пользователям (удалены из slots.json)
- Пользователь видит только свободные слоты из slots.json

**Экран "Мои записи" (My Bookings)**:
- Слоты с `status: "locking"` отображаются в отдельной секции "Ожидают оплаты"
- Показать таймер обратного отсчета
- Кнопка "Оплатить" (повторное открытие ссылки)
- Кнопка "Отменить" (опционально — освобождает слот)

**Кнопка MainButton "Забронировать"**:
- Текст остаётся прежним: "Забронировать"
- При клике создаётся платёж и сразу открывается платёжная страница Юкассы
- Если пользователь закрыл окно оплаты, может вернуться через "Мои записи"

---

## Производительность

### Оптимизации

**API вызовы**:
- Один запрос для создания платежа (не два отдельных: бронирование + платёж)
- Кеширование slots.json на фронтенде (TTL 10 минут), но с инвалидацией при бронировании
- Webhook от Юкассы обрабатывается асинхронно (не блокирует фронтенд)

**Рендеринг**:
- Таймеры обновляются не чаще раз в минуту (setInterval 60000ms)
- Используем DocumentFragment для множественного рендеринга слотов

**Память**:
- Очистка старых timers при переключении табов
- Ограничение количества одновременных запросов (AbortController)

### Целевые метрики

- Время создания платежа: < 3 секунд
- Время открытия WebView: < 500 мс
- Обработка webhook от Юкассы: < 2 секунд
- Обновление slots.json в git: < 5 секунд

---

## Безопасность

**Frontend**:
- Валидация: slotId (формат: `[a-z]slot_\d+`), serviceId (из списка STATIC_SERVICES)
- Проверка user_id из Telegram WebApp API (нельзя подделать)
- Не передаём чувствительные данные в URL (только через POST)

**Backend (Make.com)**:
- Проверка подписи webhook от Юкассы (HMAC-SHA256)
- Валидация slot.status перед созданием платежа
- Атомарная операция: git pull → update → commit (предотвращение race condition)
- API ключи Юкассы хранятся только в Make.com (не в коде)

### Чувствительные данные

- **Не передаём в URL**: payment_url (только в ответе API)
- **Не логируем**: API ключи Юкассы, webhook signatures
- **Не храним в slots.json**: номера карт, CVV, другие PII

---

## Тестирование

### Что нужно протестировать

**Функциональное тестирование**:

- [ ] Happy path: бронирование → оплата → подтверждение работает
- [ ] Edge case 1: Пользователь не оплатил в течение 24 часов → слот освобождается
- [ ] Edge case 2: Два пользователя пытаются забронировать один слот → второй получает ошибку
- [ ] Edge case 3: Юкасса недоступна → показывается понятное сообщение
- [ ] Edge case 4: Webhook не пришёл → fallback работает
- [ ] Отмена бронирования до оплаты работает
- [ ] Таймер обратного отсчета обновляется корректно

**Нефункциональное тестирование**:

- [ ] Производительность: создание платежа < 3 сек
- [ ] HapticFeedback срабатывает при открытии оплаты и успешной оплате
- [ ] MainButton скрывается при открытии WebView
- [ ] Приложение не зависает при переключении табов во время оплаты

### Тест-кейсы

**TC-1: Успешная оплата консультации**
1. Открыть "Запись" → выбрать услугу "Пакет консультаций"
2. Выбрать доступный слот
3. Нажать "Оплатить 75 000 ₽"
4. В WebView ввести данные карты и подтвердить оплату
5. Результат: Показано уведомление "Оплата прошла!", слот появился в "Мои записи" с Zoom-ссылкой

**TC-2: Истечение TTL (24 часа)**
1. Создать бронирование с `locked_until` в прошлом (вручную в slots.json)
2. Дождаться запуска cron-задачи (раз в час) или запустить вручную
3. Обновить расписание на фронтенде
4. Результат: Слот снова отображается как `free` и доступен для бронирования

**TC-3: Race condition (два пользователя одновременно)**
1. Два пользователя (A и B) одновременно выбирают один слот
2. Пользователь A нажимает "Оплатить" первым
3. Пользователь B нажимает "Оплатить" через 1 секунду
4. Результат: Пользователь A получает payment_url, пользователь B видит ошибку "Слот уже забронирован"

---

## Риски и митигация

### Технические риски

**Риск 1: Webhook от Юкассы не доходит**
- **Вероятность**: Средняя
- **Влияние**: Высокое (слот останется в `locking` навсегда)
- **Митигация**:
  - Юкасса автоматически повторяет webhook до 3 раз
  - Добавить fallback: кнопка "Проверить статус оплаты" в "Мои записи"
  - Cron-задача раз в час проверяет статус оплаты через API Юкассы
- **План Б**: Ручная проверка оплаты администратором

**Риск 2: Пользователь закрывает приложение до завершения оплаты**
- **Вероятность**: Высокая
- **Влияние**: Среднее
- **Митигация**:
  - Слот остаётся в `locking` 24 часа
  - Пользователь может вернуться и оплатить позже через "Мои записи"
- **План Б**: Отправить push-уведомление через 1 час с напоминанием

**Риск 3: Юкасса API недоступен**
- **Вероятность**: Низкая
- **Влияние**: Критическое (невозможно принять оплату)
- **Митигация**:
  - Показать понятное сообщение: "Сервис оплаты временно недоступен"
  - Retry-логика с экспоненциальным backoff (3 попытки)
- **План Б**: Резервный способ оплаты (СБП, прямая ссылка)

**Риск 4: Race condition при обновлении slots.json**
- **Вероятность**: Низкая
- **Влияние**: Критическое (двойное бронирование)
- **Митигация**:
  - Атомарная операция в Make.com: git pull → проверка наличия слота → удаление → commit
  - Если слот уже отсутствует в slots.json — вернуть ошибку "Слот уже занят"
- **План Б**: Rollback последнего commit в git

---

## Интеграции

### Make.com

**Изменения**:
1. Новый сценарий: "Create Payment"
   - Endpoint: `/webhook/create-payment`
   - Интеграция с Юкасса API (POST `/payments`)
2. Новый webhook-приёмник: "Yookassa Webhook"
   - URL: `/webhook/yookassa` (настроить в личном кабинете Юкассы)
   - Проверка подписи (HMAC-SHA256)
3. Новый cron: "TTL Monitor"
   - Запуск: каждый час (schedule: `0 * * * *`)
   - Проверка просроченных `locking` слотов

### Yookassa

**Настройка**:
1. Создать аккаунт Юкассы (если нет)
2. Получить Shop ID и Secret Key
3. Настроить webhook URL в личном кабинете:
   - URL: `https://hook.integromat.com/xxx/yookassa`
   - События: `payment.succeeded`, `payment.canceled`
4. Добавить в Make.com переменные окружения:
   - `YOOKASSA_SHOP_ID`
   - `YOOKASSA_SECRET_KEY`

### GitHub API

**Использование** (уже настроено в T-002):
- Read/Write slots.json через PAT
- Commit message: `[T-003] Update slot status: {slot_id} → {status}`

---

## Решения и компромиссы

### Архитектурные решения

**Решение 1: TTL проверка раз в час (не реал-тайм)**
- **Проблема**: Слот может оставаться в `locking` до 1 часа после истечения TTL
- **Рассмотренные варианты**:
  - Вариант А: Cron каждую минуту (слишком частые запросы к git)
  - Вариант Б: Cron каждый час (допустимая задержка)
  - Вариант В: Проверка на фронтенде при загрузке (не надёжно)
- **Выбранное решение**: Вариант Б (cron каждый час)
- **Обоснование**: Баланс между актуальностью и нагрузкой на git. 1 час задержки допустима.

**Решение 2: Webhook от Юкассы через Make.com (не прямо на фронтенд)**
- **Проблема**: Нужно обработать успешный платёж и обновить статус слота с "locking" на "book"
- **Рассмотренные варианты**:
  - Вариант А: Webhook → Frontend (небезопасно, фронтенд может быть закрыт)
  - Вариант Б: Webhook → Make.com → обновление Data Store/Google Sheets (надёжно)
- **Выбранное решение**: Вариант Б
- **Обоснование**: Make.com всегда доступен для приёма webhook, может создать Zoom и отправить уведомление

**Решение 3: Отображение "своих" слотов в статусе locking**
- **Проблема**: Нужно показать пользователю его слоты со статусом `locking` в экране "Мои записи"
- **Рассмотренные варианты**:
  - Вариант А: Хранить locking слоты в slots.json с user_id
  - Вариант Б: Хранить locking слоты в Data Store/Google Sheets, запрашивать через Make.com
- **Выбранное решение**: Вариант Б
- **Обоснование**:
  - slots.json содержит ТОЛЬКО свободные слоты (free), формируется заранее
  - user_id появляется только при бронировании (locking/book)
  - Для отображения "своих" слотов фронтенд запрашивает Make.com с параметром user_id
  - Make.com возвращает только слоты этого пользователя из Data Store

---

## План миграции

### Миграция данных

**Существующие слоты в slots.json**:
- Все слоты с `status: "free"` остаются в slots.json без изменений
- Все слоты с `status: "book"` нужно удалить из slots.json и перенести в Data Store/Google Sheets (если еще не там)
- После миграции slots.json содержит ТОЛЬКО свободные слоты без полей `status` и `user_id`

**Скрипт миграции** (опционально, выполняется вручную в Make.com):
```javascript
// Псевдокод
const freeSlots = slots.filter(slot => slot.status === 'free' || !slot.status);
const bookedSlots = slots.filter(slot => slot.status === 'book');

// Сохранить забронированные слоты в Data Store/Google Sheets
bookedSlots.forEach(slot => {
  saveToDataStore({
    id: slot.id,
    date: slot.date,
    time: slot.time,
    service: slot.service,
    status: 'book',
    user_id: slot.user_id || findUserIdFromSheets(slot.id)
  });
});

// Обновить slots.json — только свободные слоты
updateSlotsJson(freeSlots.map(slot => ({
  id: slot.id,
  date: slot.date,
  time: slot.time,
  service: slot.service
})));
```

### Обратная совместимость

- Старая версия фронтенда (без оплаты) будет работать и отображать только свободные слоты из slots.json
- Слоты в статусе `locking` и `book` не будут видны старому фронтенду (удалены из slots.json)
- Рекомендация: обновить фронтенд одновременно с запуском Make.com сценариев для поддержки "Моих записей"

### Откат (Rollback)

Если что-то пошло не так:
1. Откатить slots.json до предыдущей версии (git revert)
2. Отключить cron "TTL Monitor" в Make.com
3. Удалить webhook в настройках Юкассы
4. Вернуть старую версию фронтенда (без оплаты)

---

## Документация

### Что нужно обновить после реализации

- [ ] `README.md` - добавить секцию "Оплата консультаций"
- [ ] Комментарии в `app.js` - JSDoc для всех новых функций
- [ ] `CHANGELOG.md` - описание изменений (v29: Интеграция Юкассы)
- [ ] `docs/tasklist/T-003.md` - обновить статус задач

---

## Чек-лист готовности плана

Перед переходом к созданию tasklist убедись:

- [x] Описана архитектура решения
- [x] Расписаны потоки данных (happy path и ошибки)
- [x] Учтены NFR (производительность, безопасность)
- [x] Описаны все интеграции с внешними системами
- [x] Выявлены риски и описана митигация
- [x] Все архитектурные решения задокументированы
- [x] Статус изменён на `PLAN_APPROVED`

**План готов! Можно начинать реализацию.**
