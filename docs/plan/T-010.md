# План реализации: T-010 - Пакет консультаций: бронирование без повторной оплаты

**Тикет**: T-010
**PRD**: `docs/prd/T-010.prd.md`
**Дата создания**: 2026-02-17
**Статус**: PLAN_READY

---

## Краткое описание

Три зоны изменений:
1. **Supabase** — 2 новые таблицы + SQL миграция
2. **Make.com Сценарий 2 (book)** — роутер + Supabase модули (описание для ручной настройки)
3. **`app.js`** — проверка пакета при загрузке + новый флоу бронирования без оплаты

---

## Часть 1: Supabase — миграция

### Файл: `supabase/migrations/20260217_user_packages.sql`

```sql
-- Таблица активных пакетов (один на пользователя)
CREATE TABLE user_packages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    telegram_user_id BIGINT NOT NULL,
    payment_id TEXT NOT NULL,
    sessions_total INT NOT NULL DEFAULT 10,
    sessions_remaining INT NOT NULL DEFAULT 9,
    status TEXT NOT NULL DEFAULT 'active',
    payment_data JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT sessions_non_negative CHECK (sessions_remaining >= 0)
);

CREATE INDEX idx_user_packages_telegram_user_id ON user_packages(telegram_user_id);

-- Лог событий: бронирование и отмена каждой сессии
CREATE TABLE package_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    package_id UUID NOT NULL REFERENCES user_packages(id),
    telegram_user_id BIGINT NOT NULL,
    event_type TEXT NOT NULL,  -- 'booked' | 'cancelled'
    booking_id TEXT,
    session_date TEXT,
    session_time TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_package_events_package_id ON package_events(package_id);
CREATE INDEX idx_package_events_telegram_user_id ON package_events(telegram_user_id);

-- RLS: фронтенд может только читать свои данные (anon key)
ALTER TABLE user_packages ENABLE ROW LEVEL SECURITY;
ALTER TABLE package_events ENABLE ROW LEVEL SECURITY;

-- Политика: чтение только своих записей (для фронтенда)
-- Make.com использует service_role key — обходит RLS
CREATE POLICY "users_read_own_packages"
    ON user_packages FOR SELECT
    USING (true);  -- фильтрация по telegram_user_id на уровне запроса

CREATE POLICY "users_read_own_events"
    ON package_events FOR SELECT
    USING (true);
```

---

## Часть 2: Make.com Сценарий 2 (book) — описание изменений

> ⚠️ Это описание для ручной настройки в Make.com интерфейсе, не код.

### Текущая структура сценария 2 (book):
```
Webhook (получает данные бронирования после оплаты)
    → создать Google Calendar событие
    → отправить Zoom invite
```

### Новая структура сценария 2:

```
Webhook
    ↓
Роутер по полю payment_type:
    ├── "package_first"    → ветка A
    ├── "package_session"  → ветка B
    └── (всё остальное)    → ветка C (текущий флоу без изменений)

Ветка A (package_first — первая сессия пакета):
    → Supabase INSERT user_packages {
        telegram_user_id, payment_id,
        sessions_total: 10, sessions_remaining: 9,
        status: 'active', payment_data
      }
    → Supabase INSERT package_events {
        package_id: <id из предыдущего шага>,
        telegram_user_id, event_type: 'booked',
        booking_id, session_date, session_time
      }
    → Google Calendar + Zoom invite (как обычно)

Ветка B (package_session — сессия 2-10):
    → Supabase UPDATE user_packages SET
        sessions_remaining = sessions_remaining - 1,
        updated_at = NOW()
        WHERE telegram_user_id = X AND status = 'active'
    → Supabase INSERT package_events {
        event_type: 'booked', ...
      }
    → Google Calendar + Zoom invite (как обычно)

Ветка C (обычная оплата):
    → текущий флоу без изменений
```

### Для сценария отмены (существующий сценарий):
Добавить ветку: если `service_id = 'package'`:
```
→ Supabase UPDATE user_packages SET
    sessions_remaining = sessions_remaining + 1,
    updated_at = NOW()
    WHERE telegram_user_id = X AND status = 'active'
→ Supabase INSERT package_events { event_type: 'cancelled', ... }
```

---

## Часть 3: app.js — изменения фронтенда

### 3.1 Новая функция: проверка активного пакета

**Где добавить**: после секции Supabase инициализации (~строка 120)

```javascript
/**
 * Проверяет наличие активного пакета консультаций у пользователя
 * @returns {Promise<Object|null>} Объект пакета или null
 */
async function checkUserPackage() {
    if (!CONFIG.SUPABASE.ENABLED || !supabaseClient) return null;
    try {
        const { data, error } = await supabaseClient
            .from('user_packages')
            .select('id, sessions_remaining, sessions_total, status')
            .eq('telegram_user_id', USER.id)
            .eq('status', 'active')
            .single();
        if (error || !data) return null;
        return data;
    } catch (e) {
        console.warn('⚠️ [checkUserPackage] Supabase недоступен, fallback на оплату');
        return null;
    }
}
```

### 3.2 Изменение в рендере карточки "Пакет консультаций"

**Где**: функция рендера услуг (renderServices / buildServicesScreen)

**Текущее поведение**: кнопка "Записаться →" всегда → экран оплаты

**Новое поведение**:
- При загрузке вкладки Услуги вызвать `checkUserPackage()`
- Если пакет активен:
  - Показать бейджик под описанием: `Осталось N из 10 сессий`
  - Кнопка "Записаться →" ведёт в бронирование с `payment_type: 'package_session'`
- Если нет пакета / 0 сессий → стандартный флоу

### 3.3 Изменение в createBooking / отправке на Make.com

**Где**: функция создания бронирования

**Добавить поле** `payment_type`:
- `'package_first'` — первая оплата пакета (приходит после YooKassa)
- `'package_session'` — последующие сессии (без оплаты)
- не передаётся — обычный флоу (как сейчас)

### 3.4 Новый флоу бронирования без оплаты (package_session)

```
Пользователь нажимает "Записаться" (пакет активен)
    ↓
Выбор слота (как обычно)
    ↓
SKIP экран оплаты
    ↓
POST на CONFIG.API.main с:
    { payment_type: 'package_session', telegram_user_id, slot, service_id: 'package', ... }
    ↓
Экран подтверждения: "Бронирование подтверждено" + "Осталось N сессий"
```

---

## Порядок реализации

```
1. Supabase миграция (создать таблицы)
2. Протестировать: вручную INSERT/SELECT через Supabase Studio
3. Make.com: добавить роутер в сценарий 2 + Supabase модули
4. Make.com: добавить ветку в сценарий отмены
5. app.js: добавить checkUserPackage()
6. app.js: изменить рендер карточки пакета (бейджик + флоу)
7. app.js: изменить createBooking (поле payment_type)
8. app.js: убрать экран оплаты для package_session
9. Тест: полный цикл вручную (первая оплата → доп. бронирование → отмена)
```

---

## Edge cases к учёту при реализации

| Ситуация | Поведение |
|---|---|
| Supabase недоступен при загрузке | fallback → стандартная оплата |
| sessions_remaining = 0 | стандартный флоу с оплатой |
| sessions_remaining = 1 | бейджик "Последняя сессия из пакета" |
| Двойной клик "Записаться" | существующий locking сценарий блокирует |
| Отмена сессии | sessions_remaining + 1, лог в package_events |

---

## Файлы, которые изменяются

| Файл | Изменение |
|---|---|
| `supabase/migrations/20260217_user_packages.sql` | новый файл (миграция) |
| `app.js` | +checkUserPackage(), изменение рендера карточки пакета, createBooking |
| `styles.css` | +стиль бейджика "Осталось N сессий" |
| `index.html` | версия v70 |
| Make.com Сценарий 2 | роутер + Supabase модули (ручная настройка) |
| Make.com Сценарий отмены | ветка для пакета (ручная настройка) |
