# План реализации: T-008 - Политика конфиденциальности и согласие на обработку ПД

**Тикет**: T-008
**PRD**: `docs/prd/T-008.prd.md`
**Дата создания**: 2026-02-15

---

## Обзор

Реализовать модалку с согласием на политику конфиденциальности и обработку персональных данных при первом входе пользователя. Логировать согласия в Supabase PostgreSQL через Make.com webhook. Юридическая защита по 152-ФЗ "О персональных данных".

---

## Архитектурные решения

### 1. Хранение согласий (3-уровневая архитектура)

**Уровень 1: Supabase PostgreSQL** (источник истины)
- Таблица `user_consents` с RLS политиками
- Поля: `telegram_user_id`, `consent_type`, `telegram_username`, `created_at`, `policy_version`
- Индексы: `(telegram_user_id, consent_type)` для быстрого поиска
- Уникальность: constraint на `(telegram_user_id, consent_type)`

**Уровень 2: Make.com webhook** (мост между фронтендом и базой)
- Новый сценарий: Custom Webhook → HTTP POST to Supabase
- Защита: service_role key в заголовках (hardcoded, Вариант 1)
- Валидация: проверка обязательных полей (user_id, consent_type)

**Уровень 3: localStorage** (кеш для UX)
- Ключ: `consent_given_${userId}`
- Значение: `true` или отсутствует
- Цель: не показывать модалку повторно при каждом запуске

### 2. Модалка согласия (UI/UX)

**Дизайн**:
- Glass-card эффект (существующий паттерн)
- Beige цвет ссылок: `#C8B8A0`
- Блокировка фона: `z-index: 10000`, клик вне модалки не закрывает
- Haptic feedback при клике "Согласен и продолжить"

**Логика показа**:
```javascript
// При загрузке app.js (в конце DOMContentLoaded)
const userId = tg.initDataUnsafe?.user?.id;
const consentGiven = localStorage.getItem(`consent_given_${userId}`);

if (!consentGiven) {
  showConsentModal(); // Показать модалку
} else {
  // Пропустить, пользователь уже согласился
}
```

### 3. Типы согласий (consent_type)

| Тип | Когда логируется | Таблица |
|-----|------------------|---------|
| `privacy_policy` | Нажатие "Согласен и продолжить" в модалке | `user_consents` |
| `personal_data` | Нажатие "Согласен и продолжить" в модалке | `user_consents` |
| `offer_contract_club` | Успешная оплата клуба (уже есть) | `club_payments.created_at` |
| `offer_contract_booking` | Успешная оплата бронирования | `user_consents` |

**Примечание**: При клике на "Согласен и продолжить" логируются **два** согласия: `privacy_policy` и `personal_data` (два отдельных INSERT в Supabase).

---

## План изменений по файлам

### Файл 1: `config.js`

**Добавить** (после блока SUPABASE):

```javascript
// [T-008] User Consents - Политика конфиденциальности и ПД
CONSENTS: {
    /** Make.com webhook для логирования согласий */
    WEBHOOK_URL: 'ВАШ_URL_ВЕБХУКА_ПОСЛЕ_СОЗДАНИЯ_В_MAKE',
    /** Версия политики (для версионирования) */
    POLICY_VERSION: '1.0',
    /** Ссылки на документы */
    PRIVACY_POLICY_URL: 'https://arinaprovodnik.com/politica',
    PERSONAL_DATA_URL: 'https://arinaprovodnik.com/person'
},
```

---

### Файл 2: `index.html`

**Добавить модалку** (перед закрывающим `</body>`):

```html
<!-- [T-008] Модалка согласия на политику конфиденциальности -->
<div id="consent-modal-overlay" class="modal-overlay" style="display: none;">
  <div class="consent-modal glass-card">
    <h2>Добро пожаловать!</h2>
    <p class="consent-text">Чтобы продолжить, ознакомьтесь с документами</p>
    <div class="consent-links">
      <a href="https://arinaprovodnik.com/politica" target="_blank" class="consent-link">
        Политика конфиденциальности
      </a>
      <a href="https://arinaprovodnik.com/person" target="_blank" class="consent-link">
        Согласие на обработку ПД
      </a>
    </div>
    <button id="consent-agree-btn" class="primary-btn">Согласен и продолжить</button>
  </div>
</div>
```

---

### Файл 3: `styles.css`

**Добавить стили** (в конец файла):

```css
/* [T-008] Модалка согласия на политику конфиденциальности */
.consent-modal {
  max-width: 400px;
  width: 90%;
  padding: 28px 24px;
  text-align: center;
  animation: fadeInScale 0.3s ease-out;
}

.consent-modal h2 {
  font-size: 24px;
  font-weight: 600;
  color: #2C2C2C;
  margin: 0 0 12px 0;
}

.consent-text {
  font-size: 15px;
  color: #666;
  margin: 0 0 20px 0;
  line-height: 1.5;
}

.consent-links {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 24px;
}

.consent-link {
  color: #C8B8A0; /* Beige */
  font-size: 15px;
  font-weight: 500;
  text-decoration: none;
  padding: 8px;
  border-radius: 8px;
  transition: background 0.2s;
}

.consent-link:hover {
  background: rgba(200, 184, 160, 0.1);
}

.consent-link:active {
  background: rgba(200, 184, 160, 0.2);
}

@keyframes fadeInScale {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}
```

---

### Файл 4: `app.js`

#### Изменение 1: Функция проверки и показа модалки (добавить в конец `DOMContentLoaded`)

**Добавить перед `initApp()`**:

```javascript
// [T-008] Проверка согласия на политику конфиденциальности
function checkAndShowConsentModal() {
  const userId = tg.initDataUnsafe?.user?.id;

  // Если нет user_id (не должно быть в Telegram WebApp), пропускаем
  if (!userId) {
    console.warn('[T-008] User ID not found, skipping consent modal');
    return;
  }

  const consentGiven = localStorage.getItem(`consent_given_${userId}`);

  if (!consentGiven) {
    // Пользователь ещё не согласился → показываем модалку
    showConsentModal();
  } else {
    console.log('[T-008] Consent already given, skipping modal');
  }
}

// Вызов после инициализации Telegram WebApp
checkAndShowConsentModal();
```

#### Изменение 2: Функция показа модалки

**Добавить** (рядом с другими модалками):

```javascript
/**
 * [T-008] Показывает модалку согласия на политику конфиденциальности
 */
function showConsentModal() {
  const overlay = document.getElementById('consent-modal-overlay');
  if (!overlay) {
    console.error('[T-008] Consent modal overlay not found');
    return;
  }

  overlay.style.display = 'flex'; // Показать модалку

  // Haptic feedback (уведомление)
  tg.HapticFeedback.notificationOccurred('warning');

  // Обработчик кнопки "Согласен и продолжить"
  const agreeBtn = document.getElementById('consent-agree-btn');
  if (agreeBtn) {
    agreeBtn.onclick = handleConsentAgree;
  }

  // Блокировка закрытия по клику вне модалки
  overlay.onclick = (e) => {
    if (e.target === overlay) {
      // Не закрывать! Пользователь ДОЛЖЕН согласиться
      tg.HapticFeedback.notificationOccurred('error');
    }
  };
}
```

#### Изменение 3: Обработчик нажатия "Согласен и продолжить"

**Добавить**:

```javascript
/**
 * [T-008] Обработчик нажатия кнопки "Согласен и продолжить"
 * Логирует два согласия: privacy_policy и personal_data
 */
async function handleConsentAgree() {
  const userId = tg.initDataUnsafe?.user?.id;
  const username = tg.initDataUnsafe?.user?.username ||
                   tg.initDataUnsafe?.user?.first_name ||
                   'Unknown';

  // Haptic feedback
  tg.HapticFeedback.notificationOccurred('success');

  // Показать loading (используем существующую функцию)
  showLoadingModal('Сохранение согласия...');

  try {
    // Логируем ОБА согласия в Supabase через Make.com
    await Promise.all([
      logConsent(userId, username, 'privacy_policy'),
      logConsent(userId, username, 'personal_data')
    ]);

    // Сохраняем в localStorage (чтобы не показывать модалку повторно)
    localStorage.setItem(`consent_given_${userId}`, 'true');

    // Закрываем модалку
    const overlay = document.getElementById('consent-modal-overlay');
    if (overlay) overlay.style.display = 'none';

    hideLoadingModal();

    console.log('[T-008] Consent saved successfully');

  } catch (error) {
    hideLoadingModal();
    console.error('[T-008] Failed to save consent:', error);

    // Показываем ошибку пользователю
    tg.showAlert('Не удалось сохранить согласие. Попробуйте позже.');
    tg.HapticFeedback.notificationOccurred('error');
  }
}
```

#### Изменение 4: Функция логирования согласия в Supabase

**Добавить**:

```javascript
/**
 * [T-008] Логирует согласие пользователя в Supabase через Make.com webhook
 * @param {number} userId - Telegram user ID
 * @param {string} username - Telegram username или first_name
 * @param {string} consentType - Тип согласия (privacy_policy, personal_data, offer_contract_booking)
 * @returns {Promise<void>}
 */
async function logConsent(userId, username, consentType) {
  const webhookUrl = CONFIG.CONSENTS.WEBHOOK_URL;

  if (!webhookUrl || webhookUrl === 'ВАШ_URL_ВЕБХУКА_ПОСЛЕ_СОЗДАНИЯ_В_MAKE') {
    console.warn('[T-008] Consent webhook URL not configured, skipping logging');
    return; // Не блокируем UX, если webhook не настроен
  }

  const payload = {
    telegram_user_id: userId,
    telegram_username: username,
    consent_type: consentType,
    consent_given: true,
    policy_version: CONFIG.CONSENTS.POLICY_VERSION,
    user_agent: navigator.userAgent // Для юридической защиты (опционально)
  };

  const response = await fetch(webhookUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  console.log(`[T-008] Logged consent: ${consentType} for user ${userId}`);
}
```

#### Изменение 5: Добавить логирование согласия при оплате бронирований

**В функции `confirmBooking()` после успешного создания платного бронирования** (после `tg.close()`):

```javascript
// [T-008] Логируем согласие с офертой для платных услуг
if (selectedService.price > 0) {
  try {
    const userId = tg.initDataUnsafe?.user?.id;
    const username = tg.initDataUnsafe?.user?.username ||
                     tg.initDataUnsafe?.user?.first_name ||
                     'Unknown';
    await logConsent(userId, username, 'offer_contract_booking');
  } catch (error) {
    console.error('[T-008] Failed to log offer consent for booking:', error);
    // Не показываем ошибку пользователю (не критично)
  }
}
```

---

## Edge Cases и обработка ошибок

### Edge Case 1: localStorage очищен пользователем

**Проблема**: Пользователь согласился, но удалил localStorage → модалка показывается повторно.

**Решение**: Это ОК! Согласие уже в Supabase (источник истины). localStorage — только для UX. Пользователь может согласиться снова (UNIQUE constraint предотвратит дубли).

### Edge Case 2: Make.com webhook недоступен (timeout/500 ошибка)

**Проблема**: Согласие не сохранилось в Supabase, но модалка закрылась.

**Решение**:
- `try/catch` в `handleConsentAgree()`
- При ошибке: `tg.showAlert()` с просьбой попробовать позже
- `localStorage` НЕ сохраняется при ошибке
- При следующем запуске модалка появится снова

### Edge Case 3: User ID отсутствует (теоретически невозможно в Telegram WebApp)

**Проблема**: `tg.initDataUnsafe?.user?.id` = `undefined`.

**Решение**: Проверка в `checkAndShowConsentModal()` → если нет ID, пропускаем модалку + `console.warn()`.

### Edge Case 4: Дубликат согласия (пользователь дважды нажал "Согласен")

**Проблема**: Два параллельных запроса в Make.com → попытка вставить дублирующую запись.

**Решение**:
- **Supabase**: UNIQUE constraint `(telegram_user_id, consent_type)` → второй INSERT вернёт ошибку 409 Conflict
- **Make.com**: Игнорировать ошибку 409 (согласие уже есть = ОК)

### Edge Case 5: Пользователь не нажал "Согласен" и закрыл приложение

**Проблема**: Модалка блокирует UI, пользователь не может использовать приложение.

**Решение**: **ПО ДИЗАЙНУ**. Без согласия приложение не должно работать (юридическое требование 152-ФЗ).

---

## Тестирование

### Тест 1: Первый запуск (согласие отсутствует)

**Шаги**:
1. Очистить localStorage: `localStorage.clear()`
2. Перезагрузить приложение
3. Проверить: модалка появилась сразу после загрузки

**Ожидаемый результат**:
- Модалка блокирует весь экран (z-index: 10000)
- Текст: "Добро пожаловать!"
- Две ссылки в beige цвете (#C8B8A0)
- Кнопка "Согласен и продолжить"
- Клик вне модалки НЕ закрывает её (haptic error)

### Тест 2: Нажатие "Согласен и продолжить"

**Шаги**:
1. Нажать кнопку "Согласен и продолжить"
2. Дождаться закрытия модалки

**Ожидаемый результат**:
- Haptic feedback (success)
- Loading modal "Сохранение согласия..." (~1-2 сек)
- Модалка закрывается
- В localStorage появился ключ `consent_given_123456` = `true`
- В DevTools Network: 2 POST запроса в Make.com webhook (privacy_policy + personal_data)

### Тест 3: Повторный запуск (согласие уже есть)

**Шаги**:
1. Перезагрузить приложение (F5)
2. Проверить: модалка НЕ показывается

**Ожидаемый результат**:
- Модалка не появляется
- В console.log: `[T-008] Consent already given, skipping modal`
- Приложение загружается нормально

### Тест 4: Ошибка Make.com webhook (симуляция)

**Шаги**:
1. В `config.js` временно изменить `WEBHOOK_URL` на несуществующий
2. Очистить localStorage
3. Перезагрузить приложение
4. Нажать "Согласен и продолжить"

**Ожидаемый результат**:
- Loading modal закрывается
- `tg.showAlert('Не удалось сохранить согласие. Попробуйте позже.')`
- Haptic feedback (error)
- Модалка НЕ закрывается (можно попробовать снова)
- `localStorage` НЕ сохранён

### Тест 5: Проверка в Supabase Table Editor

**Шаги**:
1. После успешного нажатия "Согласен" (Тест 2)
2. Открыть Supabase Dashboard → Table Editor → `user_consents`
3. Проверить: есть 2 записи

**Ожидаемый результат**:
```
| telegram_user_id | consent_type    | telegram_username | consent_given | created_at          |
|------------------|-----------------|-------------------|---------------|---------------------|
| 123456           | privacy_policy  | Sam               | true          | 2026-02-15 10:30:00 |
| 123456           | personal_data   | Sam               | true          | 2026-02-15 10:30:01 |
```

### Тест 6: Логирование согласия при оплате бронирования

**Шаги**:
1. Выбрать платную услугу (Package 75000₽ или Family 10000₽)
2. Создать бронирование
3. Оплатить через YooKassa (или симуляция webhook)
4. Проверить Supabase: есть запись `offer_contract_booking`

**Ожидаемый результат**:
```
| telegram_user_id | consent_type           | telegram_username | consent_given | created_at          |
|------------------|------------------------|-------------------|---------------|---------------------|
| 123456           | offer_contract_booking | Sam               | true          | 2026-02-15 11:00:00 |
```

---

## Метрики успеха

После завершения всех задач проверить:

- [ ] Модалка появляется < 50ms после загрузки приложения
- [ ] Согласие сохраняется в Supabase < 2 секунды
- [ ] Webhook success rate > 95% (проверить в Make.com History)
- [ ] Нет дублирующих записей в Supabase (UNIQUE constraint работает)
- [ ] При ошибке webhook пользователь видит понятное сообщение
- [ ] Согласие при оплате бронирований логируется корректно

---

## Чек-лист готовности

- [x] PRD утверждён
- [x] Архитектурные решения приняты (Supabase + localStorage + Make.com)
- [x] Plan изменений готов
- [x] Edge cases продуманы
- [x] Тестовые сценарии расписаны
- [x] Make.com webhook стратегия выбрана (Вариант 1 - hardcode key)

**Готов к реализации!** ✅

---

## Следующие шаги

1. **Supabase Setup**:
   - Скопировать SQL скрипт `docs/supabase-user-consents.sql`
   - Выполнить в Supabase Dashboard → SQL Editor
   - Проверить таблицу создана: `SELECT * FROM user_consents LIMIT 1;`

2. **Make.com Webhook**:
   - Создать новый сценарий (Custom Webhook → HTTP Request to Supabase)
   - Скопировать URL webhook
   - Обновить `config.js` → `CONSENTS.WEBHOOK_URL`

3. **Frontend реализация**:
   - Добавить модалку в `index.html`
   - Добавить стили в `styles.css`
   - Добавить JS логику в `app.js` (функции + вызов)

4. **Тестирование**:
   - Выполнить все 6 тестов
   - Проверить в Supabase Table Editor

5. **Деплой**:
   - Commit + Push в `main`
   - Проверка в production (~2 минуты)
