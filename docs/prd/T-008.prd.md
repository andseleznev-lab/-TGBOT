# PRD: Политика конфиденциальности и согласие на обработку ПД

**Тикет**: T-008
**Автор**: Андрей Селезнев
**Дата создания**: 2026-02-15
**Статус**: PRD_READY

---

## Краткое описание

Добавить модалку с согласием на политику конфиденциальности и обработку персональных данных при первом входе пользователя. Логировать согласия в Supabase PostgreSQL для юридической защиты.

---

## Проблема / Возможность

### Контекст

**Юридическая необходимость**: По законодательству РФ (152-ФЗ "О персональных данных") требуется получить явное согласие пользователя на обработку персональных данных (имя, Telegram ID, дата рождения при бронировании).

**Проблема**: Сейчас приложение собирает данные пользователей (Telegram username, user_id) без явного согласия.

**Риск**: Штрафы за нарушение 152-ФЗ (до 75 000₽ для ИП), претензии пользователей.

### Текущая ситуация (AS IS)

- Пользователь открывает приложение → сразу видит главный экран
- Никакого запроса на согласие с политикой конфиденциальности
- Данные собираются без документального подтверждения согласия
- При оплате услуг нет ссылки на договор оферты

### Желаемая ситуация (TO BE)

**Первый запуск**:
1. Пользователь открывает приложение
2. Показывается модалка "Добро пожаловать!"
3. Модалка содержит ссылки на:
   - Политика конфиденциальности (https://arinaprovodnik.com/politica)
   - Согласие на обработку ПД (https://arinaprovodnik.com/person)
4. Кнопка "Согласен и продолжить"
5. После нажатия: согласие логируется в Supabase + localStorage

**Повторный запуск**:
- Проверка localStorage → если согласие есть, модалка НЕ показывается

**При оплате**:
- **Клуб (абонемент)**: timestamp в `club_payments.created_at` = согласие с офертой
- **Бронирование**: логируем согласие в `user_consents` с типом `offer_contract_booking`

---

## Требования

### Функциональные требования

#### Must Have

- [x] **Модалка согласия при первом входе**
  - Заголовок: "Добро пожаловать!"
  - Текст: "Чтобы продолжить, ознакомьтесь с документами"
  - Две ссылки (бежевый цвет `#C8B8A0`):
    - "Политика конфиденциальности" → https://arinaprovodnik.com/politica
    - "Согласие на обработку ПД" → https://arinaprovodnik.com/person
  - Кнопка: "Согласен и продолжить"
  - Модалка блокирует UI (нельзя закрыть без согласия)

- [x] **Логирование согласия в Supabase**
  - Таблица: `user_consents`
  - Поля: `telegram_user_id`, `telegram_username`, `consent_type`, `created_at`
  - Типы согласий:
    - `privacy_policy` - Политика конфиденциальности
    - `personal_data` - Согласие на обработку ПД
    - `offer_contract_booking` - Договор оферты при оплате бронирования
    - `offer_contract_club` - Договор оферты при оплате клуба (опционально, уже в `club_payments`)

- [x] **Кеширование в localStorage**
  - Ключ: `consent_given`
  - Значение: `{ privacy: true, personal_data: true, timestamp: ISO_DATE }`
  - При повторном запуске: проверить localStorage → пропустить модалку

- [x] **Отправка согласия в Make.com webhook**
  - Endpoint: создать новый webhook `log_consent`
  - Payload: `{ user_id, username, consent_type, timestamp }`
  - Make.com → INSERT в Supabase (через service_role ключ)

- [x] **Ссылка на договор оферты при оплате клуба**
  - Добавить текст в модалку YooKassa (перед редиректом)
  - Текст: "Оплачивая услугу, вы соглашаетесь с [Договором оферты](https://arinaprovodnik.com/oferta)"
  - Timestamp согласия = `club_payments.created_at`

- [x] **Ссылка на договор оферты при оплате бронирования**
  - Добавить текст перед редиректом в YooKassa
  - Логировать согласие: INSERT в `user_consents` с типом `offer_contract_booking`
  - Timestamp = момент нажатия кнопки "Оплатить"

#### Should Have

- [ ] **Логирование User-Agent** (опционально)
  - Поле `user_agent` в таблице `user_consents`
  - Получать из `navigator.userAgent`
  - Для юридической защиты: доказать что согласие дано с конкретного устройства

- [ ] **Версионирование политики**
  - Поле `policy_version` в `user_consents`
  - Если политика обновится → показать модалку повторно

- [ ] **Возможность отозвать согласие**
  - Кнопка в настройках: "Отозвать согласие"
  - UPDATE в Supabase: `consent_given = false`
  - Показать модалку при следующем запуске

### Нефункциональные требования (NFR)

**Производительность**:
- Проверка localStorage: < 10ms
- Отправка согласия в Make.com: < 1 секунда
- Модалка должна появляться мгновенно (< 50ms)

**Безопасность**:
- Использовать `service_role` ключ только в Make.com (НЕ в фронтенде)
- RLS политики: SELECT только для своих данных, INSERT через service_role
- Нельзя обойти модалку (блокирует весь UI)

**UX/UI**:
- Модалка в стиле приложения (glass-card, beige палитра)
- Ссылки открываются в новой вкладке (`target="_blank"`)
- Haptic feedback при нажатии "Согласен"
- Плавная анимация появления/скрытия (fade-in/fade-out 200ms)

---

## Сценарии использования

### Основной сценарий 1: Первый вход пользователя (Happy Path)

**Действующие лица**: Пользователь, Система, Make.com, Supabase

**Предусловия**:
- Пользователь открывает приложение впервые
- В localStorage НЕТ ключа `consent_given`

**Шаги**:
1. Пользователь открывает Telegram Mini App
2. Система проверяет `localStorage.getItem('consent_given')` → null
3. Система показывает модалку "Добро пожаловать!"
4. Пользователь читает текст, кликает на ссылки (открываются в новой вкладке)
5. Пользователь нажимает "Согласен и продолжить"
6. Система:
   - Haptic feedback (`selectionChanged()`)
   - Сохраняет в localStorage: `{ privacy: true, personal_data: true, timestamp }`
   - Отправляет webhook в Make.com: `{ user_id, username, consent_type: 'privacy_policy', timestamp }`
   - Отправляет webhook в Make.com: `{ user_id, username, consent_type: 'personal_data', timestamp }`
7. Make.com вставляет 2 записи в `user_consents`
8. Система скрывает модалку (fade-out)
9. Пользователь видит главный экран приложения

**Результат**:
- Согласие задокументировано в Supabase
- Пользователь может пользоваться приложением
- При следующем запуске модалка НЕ показывается

---

### Основной сценарий 2: Повторный вход пользователя

**Предусловия**:
- Пользователь уже согласился с политикой
- В localStorage ЕСТЬ ключ `consent_given`

**Шаги**:
1. Пользователь открывает приложение
2. Система проверяет `localStorage.getItem('consent_given')` → `{ privacy: true, ... }`
3. Система НЕ показывает модалку
4. Пользователь видит главный экран сразу

**Результат**:
- Модалка НЕ показывается
- Пользователь не тратит время

---

### Основной сценарий 3: Оплата клуба (абонемент)

**Предусловия**:
- Пользователь уже согласился с политикой
- Пользователь выбрал "Купить абонемент 2990₽"

**Шаги**:
1. Пользователь нажимает "Купить абонемент"
2. Система показывает модалку YooKassa
3. В модалке текст: "Оплачивая услугу, вы соглашаетесь с [Договором оферты](ссылка)"
4. Пользователь нажимает "Оплатить"
5. Редирект в YooKassa → оплата
6. YooKassa webhook → Make.com → INSERT в `club_payments`
7. Timestamp `club_payments.created_at` = согласие с офертой

**Результат**:
- Согласие с офертой задокументировано
- Юридически защищены

---

### Основной сценарий 4: Оплата бронирования

**Предусловия**:
- Пользователь выбрал платную услугу (например, "Ведическая астрология")
- Выбрал дату и время

**Шаги**:
1. Пользователь нажимает "Оплатить 2500₽"
2. Система показывает модалку с текстом: "Оплачивая, вы соглашаетесь с [Договором оферты](ссылка)"
3. Пользователь нажимает "Оплатить"
4. Система:
   - Отправляет webhook в Make.com: `{ user_id, username, consent_type: 'offer_contract_booking', timestamp }`
   - Редирект в YooKassa
5. Make.com вставляет запись в `user_consents`
6. Пользователь оплачивает → webhook от YooKassa → Make.com создаёт бронирование

**Результат**:
- Согласие с офертой задокументировано
- Юридически защищены

---

### Исключительные ситуации (Edge Cases)

**Ошибка 1: Нет интернета при показе модалки**
- **Причина**: Пользователь открыл приложение без интернета
- **Обработка**: Модалка показывается (работает офлайн)
- **Сообщение пользователю**: Ссылки не открываются → показать toast "Проверьте подключение к интернету"

**Ошибка 2: Make.com webhook не отвечает (таймаут)**
- **Причина**: Make.com недоступен или медленно отвечает
- **Обработка**: Модалка скрывается (localStorage сохранён), retry в фоне
- **Логирование**: Console warning, но пользователь продолжает работу

**Ошибка 3: Пользователь очистил localStorage**
- **Причина**: Пользователь очистил кеш браузера/Telegram
- **Обработка**: Модалка показывается снова
- **Результат**: Новая запись в `user_consents` (дубликат), но это ОК (юридически корректно)

**Ошибка 4: Пользователь нажал "Назад" в браузере при модалке**
- **Причина**: Попытка обойти модалку
- **Обработка**: Модалка блокирует UI, кнопка "Назад" не работает
- **Альтернатива**: Если пользователь закрыл Telegram → при следующем запуске модалка показывается снова

---

## UI/UX Дизайн

### Модалка согласия

**HTML структура**:
```html
<div id="consent-modal-overlay" class="modal-overlay">
  <div class="consent-modal glass-card">
    <h2>Добро пожаловать!</h2>
    <p class="consent-text">
      Чтобы продолжить, ознакомьтесь с документами
    </p>

    <div class="consent-links">
      <a href="https://arinaprovodnik.com/politica"
         target="_blank"
         class="consent-link">
        Политика конфиденциальности
      </a>

      <a href="https://arinaprovodnik.com/person"
         target="_blank"
         class="consent-link">
        Согласие на обработку ПД
      </a>
    </div>

    <button id="consent-agree-btn" class="primary-btn">
      Согласен и продолжить
    </button>
  </div>
</div>
```

**CSS стили**:
```css
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(8px);
  z-index: 10000; /* Выше всех элементов */
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: opacity 200ms ease;
}

.modal-overlay.active {
  opacity: 1;
}

.consent-modal {
  background: white;
  border-radius: 20px;
  padding: 32px 24px;
  max-width: 400px;
  width: 90%;
  text-align: center;
}

.consent-modal h2 {
  font-size: 24px;
  font-weight: 600;
  color: #8B7355;
  margin-bottom: 16px;
}

.consent-text {
  font-size: 16px;
  color: #666;
  margin-bottom: 24px;
  line-height: 1.5;
}

.consent-links {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 24px;
}

.consent-link {
  color: #C8B8A0; /* Бежевый цвет */
  text-decoration: underline;
  font-size: 16px;
  cursor: pointer;
  transition: color 200ms ease;
}

.consent-link:hover {
  color: #B8A890; /* Темнее при наведении */
}

#consent-agree-btn {
  width: 100%;
  padding: 14px;
  background: linear-gradient(135deg, #FF9D5C, #FF7A3D);
  color: white;
  border: none;
  border-radius: 12px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: transform 200ms ease;
}

#consent-agree-btn:active {
  transform: scale(0.98);
}
```

**JavaScript логика**:
```javascript
function checkConsent() {
  const consent = localStorage.getItem('consent_given');
  if (!consent) {
    showConsentModal();
  }
}

function showConsentModal() {
  const overlay = document.getElementById('consent-modal-overlay');
  overlay.classList.add('active');

  document.getElementById('consent-agree-btn').addEventListener('click', handleConsentAgree);
}

async function handleConsentAgree() {
  // Haptic feedback
  if (tg.HapticFeedback) {
    tg.HapticFeedback.selectionChanged();
  }

  // Сохранить в localStorage
  const consentData = {
    privacy: true,
    personal_data: true,
    timestamp: new Date().toISOString()
  };
  localStorage.setItem('consent_given', JSON.stringify(consentData));

  // Отправить в Make.com (2 запроса)
  const userId = tg.initDataUnsafe?.user?.id;
  const username = tg.initDataUnsafe?.user?.username || tg.initDataUnsafe?.user?.first_name;

  try {
    await fetch(CONFIG.MAKE_WEBHOOKS.LOG_CONSENT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        user_id: userId,
        username: username,
        consent_type: 'privacy_policy',
        timestamp: consentData.timestamp
      })
    });

    await fetch(CONFIG.MAKE_WEBHOOKS.LOG_CONSENT, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        user_id: userId,
        username: username,
        consent_type: 'personal_data',
        timestamp: consentData.timestamp
      })
    });
  } catch (error) {
    console.warn('Failed to log consent:', error);
    // Продолжаем работу даже при ошибке
  }

  // Скрыть модалку
  hideConsentModal();
}

function hideConsentModal() {
  const overlay = document.getElementById('consent-modal-overlay');
  overlay.classList.remove('active');
}
```

---

### Модалка оферты при оплате

**Модификация существующей модалки YooKassa**:

**HTML добавление**:
```html
<div class="yookassa-modal">
  <!-- Existing content -->

  <!-- NEW: Ссылка на оферту -->
  <p class="offer-text">
    Оплачивая услугу, вы соглашаетесь с
    <a href="https://arinaprovodnik.com/oferta"
       target="_blank"
       class="offer-link">
      Договором оферты
    </a>
  </p>

  <button id="pay-btn">Оплатить</button>
</div>
```

**CSS добавление**:
```css
.offer-text {
  font-size: 12px;
  color: #999;
  margin: 16px 0;
  text-align: center;
  line-height: 1.4;
}

.offer-link {
  color: #C8B8A0;
  text-decoration: underline;
}
```

---

### Взаимодействия

**Клик на "Согласен и продолжить"**:
- Haptic feedback (`selectionChanged()`)
- Сохранение в localStorage
- Отправка webhook в Make.com (2 запроса)
- Fade-out модалки (200ms)
- Переход на главный экран

**Клик на ссылку "Политика конфиденциальности"**:
- Открывается в новой вкладке (`target="_blank"`)
- Модалка остаётся открытой

**Клик на ссылку "Согласие на обработку ПД"**:
- Открывается в новой вкладке
- Модалка остаётся открытой

**Клик на "Оплатить" (клуб/бронирование)**:
- Логируется согласие с офертой (webhook → Supabase)
- Редирект в YooKassa

---

## Зависимости

### Внешние системы

**Make.com**:
- Новый webhook: `LOG_CONSENT`
- Endpoint: `https://hook.eu2.make.com/...` (создать новый)
- Payload: `{ user_id, username, consent_type, timestamp }`
- Действие: HTTP POST → Supabase (INSERT в `user_consents`)

**Supabase**:
- Таблица: `user_consents`
- RLS политики: SELECT (anon), INSERT (service_role only)
- Индексы: `(telegram_user_id, consent_type)`

**Telegram Mini Apps**:
- `tg.initDataUnsafe.user.id` - Telegram user ID
- `tg.initDataUnsafe.user.username` - Telegram username
- `tg.HapticFeedback.selectionChanged()` - Haptic feedback

### Внутренние зависимости

**Файлы**:
- `index.html`:
  - Добавить HTML модалку согласия
  - Добавить текст оферты в модалку YooKassa
- `app.js`:
  - Добавить `checkConsent()` в `initApp()`
  - Добавить функции: `showConsentModal()`, `handleConsentAgree()`, `hideConsentModal()`
  - Модифицировать `createPayment()` → логировать согласие с офертой
- `config.js`:
  - Добавить `MAKE_WEBHOOKS.LOG_CONSENT`

**Компоненты**:
- localStorage API (встроенное)
- Fetch API (встроенное)
- Существующая модальная система (glass-card стили)

---

## Метрики успеха

### Количественные метрики

**Модалка согласия**:
- Время показа модалки: < 50ms после запуска приложения
- Время скрытия модалки: < 300ms (200ms анимация + 100ms задержка)
- Успешная отправка webhook: > 95% (5% допустимо для retry)

**Логирование**:
- Все согласия сохраняются в Supabase (100%)
- Нет дубликатов для одного пользователя (проверка через SQL запрос)

**localStorage**:
- Кеш работает корректно (модалка НЕ показывается при повторном входе)

### Качественные метрики

- Пользователь понимает зачем нужна модалка (не раздражает)
- Ссылки открываются в новой вкладке (удобно)
- Модалка не блокирует работу (можно прочитать политику и вернуться)
- Юридически корректно (согласие задокументировано)

---

## Риски и ограничения

### Технические риски

**Риск 1: Пользователь очистил localStorage**
- **Вероятность**: Средняя (если пользователь очистил кеш Telegram)
- **Влияние**: Низкое (модалка показывается снова, новая запись в БД)
- **Митигация**: Это нормально, дубликаты допустимы (юридически корректно)

**Риск 2: Make.com webhook не отвечает**
- **Вероятность**: Низкая (Make.com uptime > 99%)
- **Влияние**: Среднее (согласие не залогировано в Supabase)
- **Митигация**:
  - localStorage сохранён → пользователь продолжает работу
  - Retry логику можно добавить позже (Should Have)
  - Console warning для отладки

**Риск 3: Модалка блокирует работу навсегда (баг)**
- **Вероятность**: Низкая (если баг в коде)
- **Влияние**: Критическое (пользователь не может пользоваться приложением)
- **Митигация**:
  - Тщательное тестирование перед деплоем
  - Fallback: если модалка открыта > 5 минут → автозакрытие + localStorage = true

**Риск 4: Ссылки на политику недоступны (404)**
- **Вероятность**: Низкая (ссылки уже работают)
- **Влияние**: Среднее (пользователь не может прочитать политику)
- **Митигация**: Проверить ссылки перед деплоем

### Ограничения

- **Нет версионирования политики**: Если политика обновится, пользователь НЕ увидит новую модалку (можно добавить в Should Have)
- **Нет возможности отозвать согласие**: Юридически может потребоваться (можно добавить в Should Have)
- **localStorage может быть недоступен**: В Private Mode браузера (редко для Telegram Mini Apps)

---

## Открытые вопросы

- [x] **Вопрос 1**: Какой текст показывать в модалке?
  - **Решение**: "Добро пожаловать! Чтобы продолжить, ознакомьтесь с документами"

- [x] **Вопрос 2**: Какой цвет для ссылок?
  - **Решение**: Бежевый `#C8B8A0` (соответствует палитре приложения)

- [x] **Вопрос 3**: Нужен ли User-Agent?
  - **Решение**: Should Have (опционально), можно добавить позже

- [x] **Вопрос 4**: Где логировать согласие с офертой для бронирования?
  - **Решение**: В таблицу `user_consents` с типом `offer_contract_booking`

---

## Решения и уточнения

### Решение по вопросу 1: Архитектура хранения
**2026-02-15**: Использовать Supabase PostgreSQL + localStorage (Вариант 1). Это консистентно с T-006 (club_payments) и обеспечивает юридическую защиту.

### Решение по вопросу 2: Модалка блокирует UI
**2026-02-15**: Модалка должна блокировать весь UI (нельзя закрыть без согласия). Это юридически необходимо для подтверждения что пользователь осознанно согласился.

### Решение по вопросу 3: Telegram не передаёт IP адрес
**2026-02-15**: Логируем только `user_id`, `username`, `timestamp`. IP адрес недоступен в Telegram Mini Apps. User-Agent опционально (Should Have).

---

## История изменений

**2026-02-15**
Версия: 1.0 (DRAFT)
Изменения: Создан первый драфт PRD на основе обсуждения с пользователем

---

## Чек-лист готовности PRD

Перед переходом к этапу планирования убедись:

- [x] Понятна проблема и цель фичи
- [x] Описаны все must-have требования
- [x] Расписан happy path и основные edge cases
- [x] Определены метрики успеха
- [x] Выявлены риски и зависимости
- [x] Все блокирующие вопросы закрыты
- [ ] Статус изменён на `PRD_READY` (после утверждения)

**Следующий шаг**: Утверждение PRD → создание плана (plan/T-008.md) → создание tasklist (tasklist/T-008.md)
